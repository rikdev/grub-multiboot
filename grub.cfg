# ISO images
submenu 'ISO images' {
  insmod regexp
  set iso_directory=/boot/iso

  for iso_path in ${iso_directory}/*.iso; do
    regexp --set iso_name ".*/([^/]+)\.iso" "${iso_path}"
    regexp --set dist_name '([^-]+)' "${iso_name}"

    menuentry "${iso_name}" "${iso_path}" --class "${dist_name}" {
      set iso_path="$2"
      echo "Booting image: (${root})${iso_path}"
      loopback loop "${iso_path}"

      if [ -f (loop)/boot/grub/loopback.cfg ]; then
        set old_root="${root}"
        set root=(loop)
        export iso_path
        configfile /boot/grub/loopback.cfg
        set root="${old_root}"
      elif [ -f (loop)/arch/boot/x86_64/archiso.img ]; then
        # https://wiki.archlinux.org/index.php/Multiboot_USB_drive#Arch_Linux_monthly_release
        probe --fs-uuid "${root}" --set=root_uuid
        set img_dev_path="/dev/disk/by-uuid/${root_uuid}"
        linux (loop)/arch/boot/x86_64/vmlinuz img_dev="${img_dev_path}" img_loop="${iso_path}" earlymodules=loop
        initrd (loop)/arch/boot/intel_ucode.img (loop)/arch/boot/amd_ucode.img (loop)/arch/boot/x86_64/archiso.img
      else
        echo 'Error: cannot find rule to boot the image.'
        sleep --interruptible 5
      fi
    }
  done
}

# Windows Boot Manager
set windows_directory=/boot/windows
if [ "${grub_platform}" == 'efi' ]; then
  set bootmgr_path="${windows_directory}/EFI/Boot/bootx64.efi"
  if [ -f "${bootmgr_path}" ]; then
    menuentry 'Windows Boot Manager' --class windows {
      chainloader "${bootmgr_path}"
    }
  fi
else
  set bootmgr_path="${windows_directory}/bootmgr"
  if [  -f "${bootmgr_path}" ]; then
    menuentry 'Windows Boot Manager' --class windows {
      insmod ntldr
      ntldr "${bootmgr_path}"
    }
  fi
fi

# Power management
menuentry 'System shutdown' --class system {
  echo 'System shutting down...'
  halt
}
menuentry 'System restart' --class system {
  echo 'System rebooting...'
  reboot
}
